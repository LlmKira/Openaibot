# 交换系统

我们的目标是实现一个类邮件的消息交换机系统，这个系统可以在不同的系统中进行消息的传递，同时可以在不同的系统中进行消息的回复。
接受消息的系统，我们称之为“接收者”，发送消息的系统，我们称之为“发送者”。
消息带有始地址和终地址，分配给 平台和 ID，采用通用的消息格式，可以在不同的系统中进行传递。

```
Telegram -> RabbitMQ -> Telegram
Rss -> RabbitMQ -> Telegram
Api -> RabbitMQ -> Telegram
```

由各种发送器提起请求，带上终末地址，交给 OpenAi的核心函数(end_user)，调用函数核心函数返回结果，然后通知过去。

任务产生 -> 任务队列 -> 任务处理 -> 任务队列 -> 任务消费

涉及跨进程通信，需要使用消息队列，消息队列的实现有很多，我们选择 RabbitMQ。

## 创建生产者还是

消费者就是平台数目，所以消费者是有限的。

生产者由平台的用户定义并创建，有多个。

可以一起绑定一个消息队列（订阅模式），也可以使用主题模式自动分流生产者的消息。

所以消费者队列和平台绑定。

## 认证

https://www.cnblogs.com/yanzhi-1996/articles/11115010.html#exchange%E6%A8%A1%E5%9E%8B

对于生产者，有两个分类：匿名生产者和认证生产者。匿名生产者如Rss 没有用户信息，认证生产者如Telegram有用户信息。
所以对于匿名生产者，我们需要在消息中加入用户信息，也就是Redis订阅列表。在生产消息的时候，乘订阅列表发送不同 tag 的消息。

订阅的数据类应该是这样的： 平台，Userid

```python
# 声明一个队列，用于接收消息
channel.queue_declare(queue='telegram', durable=True)
channel.basic_publish(exchange='',
                      routing_key='水许传',
                      body=Message()
                      )
```

## 中间件

Openai 作为消息中间件，修改消息并转发。
如果遇到了function, 则调用function，自身作为creator发送消息。

## 订阅的实质

消息的路由。`消息类:消息源` 和 `平台:用户id` 的映射。

消息类需要了解谁订阅了这个消息类，所以需要一个消息类的订阅列表。

而我们也需要知道谁订阅了多少，所以需要一个用户的订阅列表。

```json5
{
  "rss": {
    "telegram": [
      {
        "user1": "url1"
      },
      {
        "user2": "url2"
      },
    ],
  }
}
```

```json5
{
  "rss": {
    "url1": [
      {
        "user": "platform"
      },
      {
        "user": "platform"
      },
      //...
    ]
  }
}
```

```json5
{
  "user1": {
    "rss": "",
  }
}
```

```json5
[
  {
    "from": "rss",
    "to": "telegram",
    "user": "user1",
    "url": "url1"
  }
]
```

## 插件的公共资源 / 插件管理器的设计

```
meta.json -> 所需第三方库资源和各种信息，每个文件的注册路径
public/... # 静态资源
plugin.py # 插件主文件
```

同时 public 中有公共的变量管理器供插件交互。

具体设计可以参考 none_bot （虽然机制不一样）

### 插件的实质

针对问题进行链式启动，直到执行完毕。不再局限于一问一答和文字形式。

## 插件的确认机制

对于插件操作，如果需要确认怎么办？

方案：我们可以发送命令请求信息，然后暂存当前请求链和 TaskHeader，然后命令 ``/confirm form_id`` 来确定链的继续进行和取消进行。

由此延伸，插件的表单输入也可以用暂存链。

所以需要做 暂存链管理器 + 参数修改 的人回路。

## 动态消息组构建

出于对文件系统的考虑，我们需要一个 **动态消息组构建器** ，可以从文件事件中抽取相关事件。

由于消息系统的特殊性，所以可以只在历史记录中显示简报，用插件处理数据。

## "非活动接受者"

对于非活动接受者，比如 Github Issue 平台，我们如何让Telegram和其连接？

采用订阅器即可解决此问题。

# 问题

## 多后端必要性的论证

在非 Function Call 场景下，可以使用其他的 LLM 回应消息。

但是目前本项目已经和 Openai 深度绑定，所以这是一个低优先级事项。

## Meta 信息头的暗桩

为了指示消息的处理阶段，我们有一个由混乱的命名规则组成的元信息头，这个可能是一个问题。

## “权限” 认证

添加同级的 receiver 组件进行 **认证重发**，我们需要一个认证组件，将需要认证的操作进行存储，然后通过命令释放带有通过标记的请求。（重新代发）

### 多响应方案

虽然收发广播机制看似完美，但是在实际使用中，我们发现了一个问题：**多响应**。

每次我们最多调用一个响应函数，但是在某些情况下，我们需要调用多个响应函数。

拟定方案：
方案 1. 传入拆解函数，衍生多个响应函数。
方案 2. 设定重复调用循环链条，由计数器和结束标记插件控制结束。代发机制的利用。
方案 3. “申请”运行时，然后启动问询插件。代发机制的利用。比较合理的方案。

### 重点在于变化

记录应该是变化的，用户主动时候隐藏引子，而机器人主动的时候可以 “假设” 代发请求来完成衍生任务。

### 必须收发分离

这可能是一个潜在的问题，我们的系统必须实现两个实例才能分离收发，必须需要同步API.

### 失败的补偿处理

错误禁用，手动复位。需要一个计数器。Func Loader 需要好好打磨。

### 产品定位

针对个人还是多人？

### 私有 Env 设置

需要一个私有 Env 设置，用于存储私有信息。
